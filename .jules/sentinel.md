# Sentinel Security Journal

## 2025-01-12 - Disk Exhaustion Protection in Subprocesses
**Vulnerability:** The backend executed external commands (`make`, `make run`) using `subprocess.Popen` with output redirected to a temporary file (`tempfile.TemporaryFile`). There was no limit on the size of this file. A malicious or buggy simulation could write infinite data to stdout, filling the server's disk space and causing a Denial of Service (DoS).
**Learning:** `subprocess.Popen` with `stdout=file_obj` writes directly to the file descriptor, bypassing Python-level buffering. While efficient, it lacks built-in size limits. Standard resource limits (`ulimit` / `setrlimit`) affect *all* file writes, which is unsuitable for build processes that legitimately produce large artifacts (binaries, object files) but need to limit only the log output.
**Prevention:** Implemented a polling loop in `run_command_safe` that periodically checks `os.fstat(fd).st_size`. If the limit (10MB) is exceeded, the process group is terminated. Crucially, I added a "post-mortem" check after the process exits to catch fast-running processes that might exceed the limit between poll intervals. Additionally, improved error handling to ensure the partial log (containing the error message) is returned to the user even when the process is killed.

## 2026-01-13 - Path Disclosure Mitigation
**Vulnerability:** The `list_cases` endpoint returned absolute file system paths (e.g., `/home/user/app/my_cases/Case1`) to the frontend. This exposed the server's directory structure, username, and installation path, which helps attackers map the system (Information Disclosure).
**Learning:** Returning absolute paths is often unnecessary and risky. Backend APIs should abstract the underlying filesystem. However, legacy endpoints or internal logic might rely on absolute paths (like `validate_case_path` utilizing `os.path.realpath`). Changing to relative paths required ensuring the validation logic could transparently handle both absolute (for internal backward compatibility) and relative paths.
**Prevention:** Modified the API to return paths relative to a defined root (`CASES_DIR`). Updated the input validation (`validate_case_path`) to automatically anchor incoming relative paths to this root before verification. This minimizes information leakage while maintaining functionality.

## 2026-01-14 - CSRF Mitigation via Content-Type Enforcement
**Vulnerability:** The API relied on `TrustedOriginMiddleware` (Origin/Referer checks) to prevent CSRF. However, strict reliance on these headers can be fragile (e.g., if headers are suppressed). "Simple Requests" (e.g., HTML forms using `text/plain` or `multipart/form-data`) can bypass Preflight (OPTIONS) checks, potentially allowing an attacker to send valid JSON payloads (if crafted carefully in `text/plain`) to endpoints that auto-parse bodies.
**Learning:** Enforcing `Content-Type: application/json` is a robust defense-in-depth measure against CSRF. HTML forms cannot send `application/json`; attempting to do so triggers a CORS Preflight. If the Preflight fails (due to strict CORS policy), the browser blocks the actual POST request. This effectively immunizes the API against CSRF from browser-based attackers, regardless of Origin header nuances.
**Prevention:** Implemented `StrictInputValidationMiddleware` to explicitly reject `POST`, `PUT`, and `PATCH` requests that do not match `Content-Type: application/json`. This forces all state-changing requests to be "Preflighted" by the browser, ensuring CORS policies are strictly enforced.

## 2026-01-20 - Atomic File Operations and Cleanup
**Vulnerability:** The `duplicate_case` function relied on `shutil.copytree` which is not atomic. If the operation failed midway (e.g., Disk Full), it left a partially copied directory. This "zombie" directory not only consumed disk space (contributing to DoS) but also blocked valid retries due to existence checks.
**Learning:** High-level file operations in Python like `shutil.copytree` do not offer transactional guarantees. In critical systems where filesystem state integrity is important, one must implement manual rollback mechanisms (cleanup) in `except` blocks.
**Prevention:** Wrapped `shutil.copytree` in a try-except block that explicitly checks for the existence of the target directory on failure and removes it using `shutil.rmtree`. This ensures the operation is "all-or-nothing" regarding the directory's existence.
