# Sentinel Security Journal

## 2025-01-12 - Disk Exhaustion Protection in Subprocesses
**Vulnerability:** The backend executed external commands (`make`, `make run`) using `subprocess.Popen` with output redirected to a temporary file (`tempfile.TemporaryFile`). There was no limit on the size of this file. A malicious or buggy simulation could write infinite data to stdout, filling the server's disk space and causing a Denial of Service (DoS).
**Learning:** `subprocess.Popen` with `stdout=file_obj` writes directly to the file descriptor, bypassing Python-level buffering. While efficient, it lacks built-in size limits. Standard resource limits (`ulimit` / `setrlimit`) affect *all* file writes, which is unsuitable for build processes that legitimately produce large artifacts (binaries, object files) but need to limit only the log output.
**Prevention:** Implemented a polling loop in `run_command_safe` that periodically checks `os.fstat(fd).st_size`. If the limit (10MB) is exceeded, the process group is terminated. Crucially, I added a "post-mortem" check after the process exits to catch fast-running processes that might exceed the limit between poll intervals. Additionally, improved error handling to ensure the partial log (containing the error message) is returned to the user even when the process is killed.

## 2026-01-13 - Path Disclosure Mitigation
**Vulnerability:** The `list_cases` endpoint returned absolute file system paths (e.g., `/home/user/app/my_cases/Case1`) to the frontend. This exposed the server's directory structure, username, and installation path, which helps attackers map the system (Information Disclosure).
**Learning:** Returning absolute paths is often unnecessary and risky. Backend APIs should abstract the underlying filesystem. However, legacy endpoints or internal logic might rely on absolute paths (like `validate_case_path` utilizing `os.path.realpath`). Changing to relative paths required ensuring the validation logic could transparently handle both absolute (for internal backward compatibility) and relative paths.
**Prevention:** Modified the API to return paths relative to a defined root (`CASES_DIR`). Updated the input validation (`validate_case_path`) to automatically anchor incoming relative paths to this root before verification. This minimizes information leakage while maintaining functionality.

## 2026-01-14 - CSRF Mitigation via Content-Type Enforcement
**Vulnerability:** The API relied on `TrustedOriginMiddleware` (Origin/Referer checks) to prevent CSRF. However, strict reliance on these headers can be fragile (e.g., if headers are suppressed). "Simple Requests" (e.g., HTML forms using `text/plain` or `multipart/form-data`) can bypass Preflight (OPTIONS) checks, potentially allowing an attacker to send valid JSON payloads (if crafted carefully in `text/plain`) to endpoints that auto-parse bodies.
**Learning:** Enforcing `Content-Type: application/json` is a robust defense-in-depth measure against CSRF. HTML forms cannot send `application/json`; attempting to do so triggers a CORS Preflight. If the Preflight fails (due to strict CORS policy), the browser blocks the actual POST request. This effectively immunizes the API against CSRF from browser-based attackers, regardless of Origin header nuances.
**Prevention:** Implemented `StrictInputValidationMiddleware` to explicitly reject `POST`, `PUT`, and `PATCH` requests that do not match `Content-Type: application/json`. This forces all state-changing requests to be "Preflighted" by the browser, ensuring CORS policies are strictly enforced.

## 2026-01-20 - Atomic File Operations and Cleanup
**Vulnerability:** The `duplicate_case` function relied on `shutil.copytree` which is not atomic. If the operation failed midway (e.g., Disk Full), it left a partially copied directory. This "zombie" directory not only consumed disk space (contributing to DoS) but also blocked valid retries due to existence checks.
**Learning:** High-level file operations in Python like `shutil.copytree` do not offer transactional guarantees. In critical systems where filesystem state integrity is important, one must implement manual rollback mechanisms (cleanup) in `except` blocks.
**Prevention:** Wrapped `shutil.copytree` in a try-except block that explicitly checks for the existence of the target directory on failure and removes it using `shutil.rmtree`. This ensures the operation is "all-or-nothing" regarding the directory's existence.

## 2026-01-27 - Incomplete Control Character Sanitization
**Vulnerability:** The `CONTROL_CHARS` regex (`[\x00-\x1f]`) intended to block control characters for log injection prevention failed to include the Delete character (`\x7f` or `DEL`). This oversight could allow attackers to inject `DEL` characters into logs, potentially enabling visual spoofing or obfuscation in terminal viewers.
**Learning:** Standard ASCII control character ranges are often defined as `0x00-0x1F` (C0 controls), but `0x7F` (DEL) is also a control character. Regex character ranges like `\x00-\x1f` are inclusive but do not automatically wrap to include `\x7f` unless explicitly added.
**Prevention:** When sanitizing input for "printable" ASCII, explicitly include `\x7f` in the blacklist or use a whitelist of allowed printable characters (e.g., `^[ -~]+$`). Updated the regex to `[\x00-\x1f\x7f]`.

## 2026-02-12 - CSP Directive Inheritance Gaps
**Vulnerability:** The application defined a `Content-Security-Policy` with `default-src 'self'`. While this restricts many resource types, several critical directives (`base-uri`, `form-action`, `frame-ancestors`) do *not* inherit from `default-src`. Omitting them leaves the application vulnerable to `<base>` tag hijacking (rebasing relative URLs to an attacker's domain) and unauthorized form submissions.
**Learning:** CSP inheritance rules are complex. Developers often assume `default-src` covers everything, but it only covers "fetch directives". "Navigation directives" (`form-action`) and "Document directives" (`base-uri`) must be explicitly defined. A weak policy can be as dangerous as no policy if it creates a false sense of security.
**Prevention:** Explicitly defined `base-uri 'none'`, `form-action 'self'`, and `object-src 'none'` in the security headers middleware. This ensures these specific vectors are closed, regardless of the `default-src` setting.

## 2026-02-14 - Isolation and Cross-Domain Policies
**Vulnerability:** The application lacked `Cross-Origin-Opener-Policy` (COOP) and `X-Permitted-Cross-Domain-Policies`. While basic CSP was present, the absence of COOP allows the window to be referenced by other origins (if opened via `window.open`), potentially enabling XS-Leaks (Cross-Site Leaks) or Spectre-based side-channel attacks. The absence of `X-Permitted-Cross-Domain-Policies` could allow Adobe Flash or PDF documents hosted on other domains to load data from this application if a relaxed policy file was inadvertently served (or assumed).
**Learning:** Security headers are not just about CSP. Modern browser security relies on isolating the execution context. COOP is crucial for ensuring that the application runs in a separate process group, decoupled from any potential attacker-controlled windows. Explicitly denying cross-domain policies for plugins is a simple but effective defense-in-depth measure against polyglot attacks.
**Prevention:** Added `Cross-Origin-Opener-Policy: same-origin` to strictly isolate the browsing context. Added `X-Permitted-Cross-Domain-Policies: none` to explicitly forbid cross-domain content loading by plugins.
