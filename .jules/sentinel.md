# Sentinel Security Journal

## 2025-01-12 - Disk Exhaustion Protection in Subprocesses
**Vulnerability:** The backend executed external commands (`make`, `make run`) using `subprocess.Popen` with output redirected to a temporary file (`tempfile.TemporaryFile`). There was no limit on the size of this file. A malicious or buggy simulation could write infinite data to stdout, filling the server's disk space and causing a Denial of Service (DoS).
**Learning:** `subprocess.Popen` with `stdout=file_obj` writes directly to the file descriptor, bypassing Python-level buffering. While efficient, it lacks built-in size limits. Standard resource limits (`ulimit` / `setrlimit`) affect *all* file writes, which is unsuitable for build processes that legitimately produce large artifacts (binaries, object files) but need to limit only the log output.
**Prevention:** Implemented a polling loop in `run_command_safe` that periodically checks `os.fstat(fd).st_size`. If the limit (10MB) is exceeded, the process group is terminated. Crucially, I added a "post-mortem" check after the process exits to catch fast-running processes that might exceed the limit between poll intervals. Additionally, improved error handling to ensure the partial log (containing the error message) is returned to the user even when the process is killed.

## 2026-01-13 - Path Disclosure Mitigation
**Vulnerability:** The `list_cases` endpoint returned absolute file system paths (e.g., `/home/user/app/my_cases/Case1`) to the frontend. This exposed the server's directory structure, username, and installation path, which helps attackers map the system (Information Disclosure).
**Learning:** Returning absolute paths is often unnecessary and risky. Backend APIs should abstract the underlying filesystem. However, legacy endpoints or internal logic might rely on absolute paths (like `validate_case_path` utilizing `os.path.realpath`). Changing to relative paths required ensuring the validation logic could transparently handle both absolute (for internal backward compatibility) and relative paths.
**Prevention:** Modified the API to return paths relative to a defined root (`CASES_DIR`). Updated the input validation (`validate_case_path`) to automatically anchor incoming relative paths to this root before verification. This minimizes information leakage while maintaining functionality.

## 2026-01-14 - CSRF Mitigation via Content-Type Enforcement
**Vulnerability:** The API relied on `TrustedOriginMiddleware` (Origin/Referer checks) to prevent CSRF. However, strict reliance on these headers can be fragile (e.g., if headers are suppressed). "Simple Requests" (e.g., HTML forms using `text/plain` or `multipart/form-data`) can bypass Preflight (OPTIONS) checks, potentially allowing an attacker to send valid JSON payloads (if crafted carefully in `text/plain`) to endpoints that auto-parse bodies.
**Learning:** Enforcing `Content-Type: application/json` is a robust defense-in-depth measure against CSRF. HTML forms cannot send `application/json`; attempting to do so triggers a CORS Preflight. If the Preflight fails (due to strict CORS policy), the browser blocks the actual POST request. This effectively immunizes the API against CSRF from browser-based attackers, regardless of Origin header nuances.
**Prevention:** Implemented `StrictInputValidationMiddleware` to explicitly reject `POST`, `PUT`, and `PATCH` requests that do not match `Content-Type: application/json`. This forces all state-changing requests to be "Preflighted" by the browser, ensuring CORS policies are strictly enforced.

## 2026-01-20 - Atomic File Operations and Cleanup
**Vulnerability:** The `duplicate_case` function relied on `shutil.copytree` which is not atomic. If the operation failed midway (e.g., Disk Full), it left a partially copied directory. This "zombie" directory not only consumed disk space (contributing to DoS) but also blocked valid retries due to existence checks.
**Learning:** High-level file operations in Python like `shutil.copytree` do not offer transactional guarantees. In critical systems where filesystem state integrity is important, one must implement manual rollback mechanisms (cleanup) in `except` blocks.
**Prevention:** Wrapped `shutil.copytree` in a try-except block that explicitly checks for the existence of the target directory on failure and removes it using `shutil.rmtree`. This ensures the operation is "all-or-nothing" regarding the directory's existence.

## 2026-02-12 - CSP Directive Inheritance Gaps
**Vulnerability:** The application defined a `Content-Security-Policy` with `default-src 'self'`. While this restricts many resource types, several critical directives (`base-uri`, `form-action`, `frame-ancestors`) do *not* inherit from `default-src`. Omitting them leaves the application vulnerable to `<base>` tag hijacking (rebasing relative URLs to an attacker's domain) and unauthorized form submissions.
**Learning:** CSP inheritance rules are complex. Developers often assume `default-src` covers everything, but it only covers "fetch directives". "Navigation directives" (`form-action`) and "Document directives" (`base-uri`) must be explicitly defined. A weak policy can be as dangerous as no policy if it creates a false sense of security.
**Prevention:** Explicitly defined `base-uri 'none'`, `form-action 'self'`, and `object-src 'none'` in the security headers middleware. This ensures these specific vectors are closed, regardless of the `default-src` setting.

## 2026-02-14 - Isolation and Cross-Domain Policies
**Vulnerability:** The application lacked `Cross-Origin-Opener-Policy` (COOP) and `X-Permitted-Cross-Domain-Policies`. While basic CSP was present, the absence of COOP allows the window to be referenced by other origins (if opened via `window.open`), potentially enabling XS-Leaks (Cross-Site Leaks) or Spectre-based side-channel attacks. The absence of `X-Permitted-Cross-Domain-Policies` could allow Adobe Flash or PDF documents hosted on other domains to load data from this application if a relaxed policy file was inadvertently served (or assumed).
**Learning:** Security headers are not just about CSP. Modern browser security relies on isolating the execution context. COOP is crucial for ensuring that the application runs in a separate process group, decoupled from any potential attacker-controlled windows. Explicitly denying cross-domain policies for plugins is a simple but effective defense-in-depth measure against polyglot attacks.
**Prevention:** Added `Cross-Origin-Opener-Policy: same-origin` to strictly isolate the browsing context. Added `X-Permitted-Cross-Domain-Policies: none` to explicitly forbid cross-domain content loading by plugins.

## 2026-02-05 - Rate Limiter DoS via Memory Exhaustion
**Vulnerability:** The custom `RateLimiter` stored request timestamps in a `defaultdict(deque)` keyed by IP address. The periodic cleanup mechanism iterated over *all* keys every 60 seconds to remove expired entries. An attacker could perform a Denial of Service (DoS) by sending requests with millions of spoofed IP addresses. This would cause unbounded memory growth (O(N) space) and make the cleanup loop prohibitively slow (O(N) time), blocking the single-threaded event loop and degrading availability.
**Learning:** In-memory rate limiting is fast but dangerous if the key space (IP addresses) is unbounded and attacker-controlled. `defaultdict` simplifies storage but hides the memory cost. Periodic cleanup loops that iterate over the entire dataset are a classic algorithmic complexity vulnerability when the dataset size can be manipulated by an attacker.
**Prevention:** Implemented a hard limit (`MAX_IP_COUNT`) on the number of tracked IPs. Before adding a new IP, the limiter checks the current size. If the limit is exceeded, it triggers an emergency cleanup (clearing the dictionary). This prioritizes server availability (preventing crash/hang) over strict rate limiting accuracy during a massive attack.
