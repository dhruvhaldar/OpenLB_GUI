# Sentinel Security Journal

## 2025-01-12 - Disk Exhaustion Protection in Subprocesses
**Vulnerability:** The backend executed external commands (`make`, `make run`) using `subprocess.Popen` with output redirected to a temporary file (`tempfile.TemporaryFile`). There was no limit on the size of this file. A malicious or buggy simulation could write infinite data to stdout, filling the server's disk space and causing a Denial of Service (DoS).
**Learning:** `subprocess.Popen` with `stdout=file_obj` writes directly to the file descriptor, bypassing Python-level buffering. While efficient, it lacks built-in size limits. Standard resource limits (`ulimit` / `setrlimit`) affect *all* file writes, which is unsuitable for build processes that legitimately produce large artifacts (binaries, object files) but need to limit only the log output.
**Prevention:** Implemented a polling loop in `run_command_safe` that periodically checks `os.fstat(fd).st_size`. If the limit (10MB) is exceeded, the process group is terminated. Crucially, I added a "post-mortem" check after the process exits to catch fast-running processes that might exceed the limit between poll intervals. Additionally, improved error handling to ensure the partial log (containing the error message) is returned to the user even when the process is killed.
